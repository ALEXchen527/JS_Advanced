<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // var obj1 = {
        //     name: 'tim',
        //     msg: {
        //         age: 29
        //     }
        // };

        // 1.直接赋值相当于地址的引用
        // var obj2 = obj1;
        // obj2.name = 'jim'
        // console.log(obj1.name); //jim
        // console.log(obj1 === obj2); //true


        // 2.浅拷贝只会拷贝最外面的一层，里面的对象拷贝的是地址，即引用，修改时会连着修改
        // var obj3 = {}
        // for (k in obj1) {
        //     obj3[k] = obj1[k]
        // }
        // obj3.msg.age = 30
        // console.log(obj1); //obj1.msg.age的值也会变成30，说明引用的同一块地址


        // 3.ES6中的浅拷贝
        // var obj4 = {}
        // Object.assign(obj4, obj1)
        // obj4.msg.age = 30
        // console.log(obj1); //obj1.msg.age的值也会变成30，说明引用的同一块地址



        // 深拷贝：每一层的数据都会被拷贝，开辟的都是新的空间。
        // var obj = {
        //     name: 'tim',
        //     color: ['white', 'black'],
        //     size: {
        //         content: 'small'
        //     }
        // };
        // 以下为通过函数递归的方式实现深拷贝
        // function deepCopy(newObj, oldObj) {
        //     for (k in oldObj) {
        //         // 判断是不是数组
        //         if (oldObj[k] instanceof Array) {
        //             newObj[k] = []
        //             deepCopy(newObj[k], oldObj[k]);
        //             // 判断是不是对象
        //             // ❤ 注意：需要先判断是不是数组，再判断是不是对象，因为数组也属于对象
        //         } else if (oldObj[k] instanceof Object) {
        //             newObj[k] = {}
        //             deepCopy(newObj[k], oldObj[k])
        //         } else {
        //             newObj[k] = oldObj[k]
        //         }
        //     }
        // }
        // var obj2 = {}
        // deepCopy(obj2, obj)
        // console.log(obj2);
        // obj2.color[0] = 'yellow' //深拷贝，不会改变原来的值
        // console.log(obj2);
        // console.log(obj);
    </script>
</body>

</html>